6 - shellcode and pwntools


- install di python3
> python3 -m venv venv
> source venv/bin/activate
> python3 -m pip install --upgrade pwntools


- assemble and disassemble
```
from pwn import *

context(arch='amd64', os='linux')
kode='mov eax, 0x1'
print(asm(kode))

kode='''
mov eax, 0x1
mov ebx, 0x0
int 0x80
'''
# asm
print(asm(kode))

# disasm
print(disasm(b"\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80"))

```


- test shellcode 
```
#include <stdio.h>
#include <unistd.h>

int main(){
    char buffer[64];
    printf("Buffer ada di: %p\n", &buffer);
    fflush(stdout);
    read(0, &buffer, 128);
    return 0;
}
```
> kita kan punya kontrol ke isi buffer dan ke ret addr
> gimana cara kita bisa menjalankan sembarang instruksi yg ga ada di code programnya
> contoh kita bikin buffer nya begini
mov eax, 0x1
mov ebx, 0x0
int 0x80
> lalu, ret addr kita arahkan ke perintah barusan (di arahkan ke alamat buffer)
> kalau biasanya kita isi buffernya pakai sembarang sampah (A * 16 misal), sekarang di isi ama machine code 
> misal :
\xb8 \x01 \x00 \x00
\x00 \xbb \x00 \x00
\x00 \x00 \xcd \x80
> terus, kan menuhin buffer, sekarang di ret addr dari buffernya
> nah disini mau buat custom machine code nya jadi shell, itu lah shellcode
> alamat buffer harus persis, itu susah kalau ada aslr (random offset)
> dan stack harus executable, os yg modern stack nya ga executable avoid shellcode
> disable nx di binary nya, biar shellcode nya bisa
> itulah kenapa di code ada ini :
printf("Buffer ada di: %p\n", &buffer);
> kalau gada itu susah, harus nebak